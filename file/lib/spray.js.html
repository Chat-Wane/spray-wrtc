<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/spray.js | spray-wrtc</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Adaptive random peer-sampling protocol running on top of WebRTC"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="spray-wrtc"><meta property="twitter:description" content="Adaptive random peer-sampling protocol running on top of WebRTC"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/ran3d/spray-wrtc"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/partialview.js~PartialView.html">PartialView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/spray.js~Spray.html">Spray</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#exceptions">exceptions</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exemptyview.js~ExEmptyView.html">ExEmptyView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exjoin.js~ExJoin.html">ExJoin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/exmessage.js~ExMessage.html">ExMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/exceptions/expeernotfound.js~ExPeerNotFound.html">ExPeerNotFound</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#messages">messages</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/mexchange.js~MExchange.html">MExchange</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/mjoin.js~MJoin.html">MJoin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/messages/mleave.js~MLeave.html">MLeave</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/spray.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;

const debug = (require(&apos;debug&apos;))(&apos;spray-wrtc&apos;)
const N2N = require(&apos;n2n-overlay-wrtc&apos;)
const merge = require(&apos;lodash.merge&apos;)

const PartialView = require(&apos;./partialview.js&apos;)

const MExchange = require(&apos;./messages/mexchange.js&apos;)
const MJoin = require(&apos;./messages/mjoin.js&apos;)
const MLeave = require(&apos;./messages/mleave.js&apos;)

const ExEmptyView = require(&apos;./exceptions/exemptyview.js&apos;)
const ExMessage = require(&apos;./exceptions/exmessage.js&apos;)
const ExJoin = require(&apos;./exceptions/exjoin.js&apos;)

/**
 * Implementation of the random peer-sampling Spray.
 */
class Spray extends N2N {
    /**
     * You can pass other parameters such as webrtc options
     * @param {object} [options = {}] Object with all options
     * @param {string} [options.pid = &apos;spray-wrtc&apos;] The identifier of this
     * protocol.
     * @param {number} [options.delta] Every delta milliseconds, Spray shuffles
     * its partial view with its oldest neighbor.
     * @param {number} [options.a = 1] The number of arcs at each peer converges
     * to a*log(N) + b, where N is the number of peers in the network.
     * @param {nubmer} [options.b = 0] See above.
     */
    constructor (options = {}) {
        // #0 initialize our N2N-parent
        super(merge({ pid: &apos;spray-wrtc&apos;,
                      delta: 1000 * 60 * 2,
                      timeout: 1000 * 60 * 1,
                      a: 1,
                      b: 0,
                      retry: 5 }, options))
        // #1 constants (from N2N)
        // this.PID = protocol identifier
        // this.PEER = peer Id comprising inview and outview Ids
        debug(&apos;[%s] Initalized with ==&gt; %s ==&gt;&apos;, this.PID, this.PEER)
        // #2 initialize the partial view containing ages
        this.partialView = new PartialView()
        // #3 initialize the connectedness state of this protocol
        this.state = &apos;disconnected&apos;
        // #4 periodic shuffling
        this.periodic = null
        // #5 events
        this.on(&apos;receive&apos;, (peerId, message) =&gt; this._receive(peerId, message))
        // this.on(&apos;stream&apos;, (peerId, message) =&gt; { } ); // (TODO) ?;
        this.on(&apos;open&apos;, (peerId) =&gt; {
            this._open(peerId)
            this._updateState()
        })
        this.on(&apos;close&apos;, (peerId) =&gt; {
            this._close(peerId)
            this._updateState()
        })
        this.on(&apos;fail&apos;, (peerId) =&gt; {
            this._onArcDown(peerId)
            this._updateState()
        })
    };

    /**
     * @private Start periodic shuffling.
     */
    _start (delay = this.options.delta) {
        this.periodic = setInterval(() =&gt; {
            this._exchange()
        }, delay)
    };

    /**
     * @private Stop periodic shuffling.
     */
    _stop () {
        clearInterval(this.periodic)
    };

    /**
     * @private Called each time this protocol receives a message.
     * @param {string} peerId The identifier of the peer that sent the message.
     * @param {object|MExchange|MJoin} message The message received.
     */
    _receive (peerId, message) {
        if (message.type &amp;&amp; message.type === &apos;MExchange&apos;) {
            this._onExchange(peerId, message)
        } else if (message.type &amp;&amp; message.type === &apos;MJoin&apos;) {
            this._onJoin(peerId)
        } else if (message.type &amp;&amp; message.type === &apos;MLeave&apos;) {
            this._onLeave(peerId)
        } else {
            throw new ExMessage(&apos;_receive&apos;, message, &apos;unhandled&apos;)
        };
    };

    /**
     * @private Behavior when a connection is ready to be added in the partial
     * view.
     * @param {string} peerId The identifier of the new neighbor.
     */
    _open (peerId) {
        debug(&apos;[%s] %s ===&gt; %s&apos;, this.PID, this.PEER, peerId)
        this.partialView.add(peerId)
    };

    /**
     * @private Behavior when a connection is closed.
     * @param {string} peerId The identifier of the removed arc.
     */
    _close (peerId) {
        debug(&apos;[%s] %s =&#x2020;=&gt; %s&apos;, this.PID, this.PEER, peerId)
    };

    /**
     * @private Update the connectedness state of the peer.
     */
    _updateState () {
        const remember = this.state
        if (this.i.size &gt; 0 &amp;&amp; this.o.size &gt; 0 &amp;&amp; remember !== &apos;connected&apos;) {
            this.state = &apos;connected&apos;
        } else if ((this.i.size &gt; 0 &amp;&amp; this.o.size &lt;= 0 ||
                    this.o.size &gt; 0 &amp;&amp; this.i.size &lt;= 0) &amp;&amp;
                   remember !== &apos;partially connected&apos;) {
            this.state = &apos;partially connected&apos;
        } else if (this.i.size &lt;= 0 &amp;&amp; this.o.size &lt;= 0 &amp;&amp;
                   remember !== &apos;disconnected&apos;) {
            this.state = &apos;disconnected&apos;
            // this._stop();
        };
        (remember !== this.state) &amp;&amp; this.emit(&apos;statechange&apos;, this.state)
    };

    /**
     * Joining a network.
     * @param {callback} sender Function that will be called each time an offer
     * arrives to this peer. It is the responsability of the caller to send
     * these offer (using sender) to the contact inside the network.
     * @returns {Promise} A promise that is resolved when the peer joins the
     * network -- the resolve contains the peerId; rejected after a timeout, or
     * already connected state.
     */
    join (sender) {
        let result = new Promise((resolve, reject) =&gt; {
            // #0 connectedness state check
            (this.state !== &apos;disconnected&apos;) &amp;&amp;
                reject(new ExJoin(&apos;join&apos;, &apos;Already connected.&apos;))
            // #1 set timeout before reject
            let to = setTimeout(() =&gt; {
                reject(new ExJoin(&apos;join&apos;, &apos;Timeout exceeded.&apos;))
            }, this.options.timeout)
            // #2 very first call, only done once
            this.once(&apos;open&apos;, (peerId) =&gt; {
                this.send(peerId, new MJoin(), this.options.retry)
                    .then(() =&gt; {
                        clearTimeout(to)
                        this._start() // start shuffling process
                        this._inject(this.options.a - 1, 0, peerId)
                        resolve(peerId)
                    }).catch(() =&gt; {
                        reject(new ExJoin(&apos;join&apos;,
                                          &apos;Could not notify remote contact.&apos;))
                    })
            })
        })
        // #3 engage the very first connection of this peer
        this.connect(sender)
        return result
    };

    /**
     * @private Behavior of the contact peer when a newcomer arrives.
     * @param {string} peerId The identifier of the newcomer.
     */
    _onJoin (peerId) {
        if (this.partialView.size &gt; 0) {
            // #1 all neighbors -&gt; peerId
            debug(&apos;[%s] %s ===&gt; join %s ===&gt; %s neighbors&apos;,
                  this.PID, peerId, this.PEER, this.partialView.size)
            this.partialView.forEach((ages, neighbor) =&gt; {
                ages.forEach((age) =&gt; {
                    this.connect(neighbor, peerId)
                })
            })
        } else {
            // #2 Seems like a 2-peer network;  this -&gt; peerId;
            debug(&apos;[%s] %s ===&gt; join %s ===&gt; %s&apos;,
                  this.PID, peerId, this.PEER, peerId)
            this._inject(2*this.options.a, 2*this.options.b, peerId)
            this._start()
        };
    };

    /**
     * Leave the network. If time is given, it tries to patch the network before
     * leaving.
     * @param {number} [time = 0] The time (in milliseconds) given to this peer
     * to patch the network before trully leaving.
     */
    leave (time = 0) {
        // ugly way
        const saveNITimeout = this.NI.options.timeout
        const saveNOTimeout = this.NO.options.timeout
        this.NI.options.timeout = time
        this.NO.options.timeout = time

        // #0 stop shufflings
        this._stop()
        if (time &gt; 0) {
            // #1 patch the network; in total must remove a.log(N) + b arcs
            // inview -&gt; this -&gt; outview   becomes   inview -&gt; outview
            // #A flatten the inview and the outview
            let inview = this.getInview()
            let flattenI = []
            inview.forEach((occ, peerId) =&gt; flattenI.push(peerId))
            let outview = this.getOutview()
            let flattenO = []
            outview.forEach((occ, peerId) =&gt; flattenO.push(peerId))
            // #B process the number of arc to save
            // (TODO) double check this proportion
            let toKeep = outview.size - this.options.a
            // #C bridge connections
            // (TODO) check more than 2 in flattenI and flattenO is &#x2260;
            for (let i = 0; i &lt; Math.floor(toKeep); ++i) {
                const rnI = Math.floor(Math.random() * flattenI.length)
                let different = flattenO
                    .filter((peerId) =&gt; peerId !== flattenI[rnI])
                if (different.length &gt; 0) {
                    const rnO = Math.floor(Math.random() * different.length)
                    this.connect(flattenI[rnI], different[rnO])
                };
            };
            // (TODO) add probabilistic bridging if toKeep is a floating number

            flattenI.forEach((peerId) =&gt; {
                this.send(peerId, new MLeave(), this.options.retry)
                    .catch((e) =&gt; { })
            })

            flattenO.forEach((peerId) =&gt; {
                this._onLeave(peerId)
            })
        } else {
            // #2 just leave
            this.partialView.clear()
            this.disconnect()
        };

        this.NI.options.timeout = saveNITimeout
        this.NO.options.timeout = saveNOTimeout
    };

    /**
     * @private A remote peer we target just left the network. We remove it from
     * our partial view.
     * @param {string} peerId The identifier of the peer that just left.
     */
    _onLeave (peerId) {
        if (this.partialView.has(peerId)) {
            debug(&apos;[%s] %s ==&gt; &#x2020;&#x2020;&#x2020; %s &#x2020;&#x2020;&#x2020;&apos;, this.PID, this.PEER, peerId)
            const occ = this.partialView.removeAll(peerId)
            for (let i = 0; i &lt; occ; ++i) {
                this.disconnect(peerId)
            };
        };
    };

    /**
     * Get k neighbors from the partial view. If k is not reached, it tries to
     * fill the gap with neighbors from the inview.  It is worth noting that
     * each peer controls its outview but not its inview. The more the neigbhors
     * from the outview the better.
     * @param {number} k The number of neighbors requested. If k is not defined,
     * it returns every known identifiers of the partial view.
     * @return {string[]} Array of identifiers.
     */
    getPeers (k) {
        let peers = []
        if (typeof k === &apos;undefined&apos;) {
            // #1 get all the partial view
            this.partialView.forEach((occ, peerId) =&gt; {
                peers.push(peerId)
            })
        } else {
            // #2 get random identifier from outview
            let out = []
            this.partialView.forEach((ages, peerId) =&gt; out.push(peerId))
            while (peers.length &lt; k &amp;&amp; out.length &gt; 0) {
                let rn = Math.floor(Math.random() * out.length)
                peers.push(out[rn])
                out.splice(rn, 1)
            };
            // #3 get random identifier from the inview to fill k-entries
            let inView = []
            this.i.forEach((occ, peerId) =&gt; inView.push(peerId))
            while (peers.length &lt; k &amp;&amp; inView.length &gt; 0) {
                let rn = Math.floor(Math.random() * inView.length)
                peers.push(inView[rn])
                inView.splice(rn, 1)
            };
        };
        debug(&apos;[%s] %s provides %s peers&apos;, this.PID, this.PEER, peers.length)
        return peers
    };

    /* *********************************
     * Spray&apos;s protocol implementation *
     ***********************************/

    /**
     * @private Check the partial view, i.e., weither or not connections are
     * still up and usable.
     */
    _checkPartialView () {
        let down = []
        this.partialView.forEach((ages, peerId) =&gt; {
            if (!this.o.has(peerId)) {
                down.push(peerId)
            };
        })
        down.forEach((peerId) =&gt; {
            this._onPeerDown(peerId)
        })
    };

    /**
     * @private Get a sample of the partial view.
     * @param {string} [peerId] The identifier of the oldest neighbor chosen to
     * perform a view exchange.
     * @return {string[]} An array containing the identifiers of neighbors from
     * this partial view.
     */
    _getSample (peerId) {
        let sample = []
        // #1 create a flatten version of the partial view
        let flatten = []
        this.partialView.forEach((ages, neighbor) =&gt; {
            ages.forEach((age) =&gt; {
                flatten.push(neighbor)
            })
        })
        // #2 process the size of the sample
        const sampleSize = Math.ceil(flatten.length / 2)
        // #3 initiator removes a chosen neighbor entry and adds it to sample
        if (typeof peerId !== &apos;undefined&apos;) {
            flatten.splice(flatten.indexOf(peerId), 1)
            sample.push(peerId)
        };
        // #4 add neighbors to the sample chosen at random
        while (sample.length &lt; sampleSize) {
            const rn = Math.floor(Math.random() * flatten.length)
            sample.push(flatten[rn])
            flatten.splice(rn, 1)
        };
        return sample
    };

    /**
     * @private Periodically called function that aims to balance the partial
     * view and to mix the neighborhoods.
     */
    _exchange () {
        this._checkPartialView()
        // #0 if the partial view is empty --- could be due to disconnections,
        // failure, or _onExchange started with other peers --- skip this round.
        if (this.partialView.size &lt;= 0) { return }
        this.partialView.increment()
        const oldest = this.partialView.oldest
        // #1 send the notification to oldest that we perform an exchange
        this.send(oldest, new MExchange(this.getInviewId()), this.options.retry)
            .then(() =&gt; {
                // #A setup the exchange
                // #2 get a sample from our partial view
                let sample = this._getSample(oldest)
                debug(&apos;[%s] %s ==&gt; exchange %s ==&gt; %s&apos;,
                      this.PID, this.PEER, sample.length, oldest)
                // #3 replace occurrences to oldest by ours
                sample = sample.map((peerId) =&gt; {
                    return ((peerId === oldest) &amp;&amp; this.getInviewId()) || peerId
                })
                // #4 connect oldest -&gt; sample
                sample.forEach((peerId) =&gt; {
                    this.connect(oldest, peerId)
                })
                // #5 remove our own connection
                sample = sample.map((peerId) =&gt; {
                    return ((peerId === this.getInviewId()) &amp;&amp; oldest) || peerId
                })
                sample.forEach((peerId) =&gt; {
                    this.disconnect(peerId)
                    if (peerId === oldest) {
                        this.partialView.removeOldest(peerId)
                    } else {
                        this.partialView.removeYoungest(peerId)
                    };
                })
            }).catch((e) =&gt; {
                // #B the peer cannot be reached, he is supposedly dead
                debug(&apos;[%s] %s =X&gt; exchange =X&gt; %s&apos;,
                      this.PID, this.PEER, oldest)
                this._onPeerDown(oldest)
            })
    };

    /**
     * @private Behavior when this peer receives a shuffling request.
     * @param {string} neighbor The identifier of the peer that sent this
     * exchange request.
     * @param {MExchange} message message containing the identifier of the peer
     * that started the exchange.
     */
    _onExchange (neighbor, message) {
        this._checkPartialView()
        // #1 get a sample of neighbors from our partial view
        this.partialView.increment()
        let sample = this._getSample()
        debug(&apos;[%s] %s ==&gt; exchange %s ==&gt; %s&apos;,
              this.PID, neighbor, sample.length, this.PEER)
        // #2 replace occurrences of the initiator by ours
        sample = sample.map((peerId) =&gt; {
            return (peerId === message.inview) &amp;&amp; this.getInviewId() || peerId
        })
        // #3 establish connections
        sample.forEach((peerId) =&gt; {
            this.connect(neighbor, peerId)
        })
        // #4 inverse replacement
        sample = sample.map((peerId) =&gt; {
            return (peerId === this.getInviewId()) &amp;&amp; message.inview || peerId
        })
        // #5 disconnect arcs
        sample.forEach((peerId) =&gt; {
            this.disconnect(peerId)
            this.partialView.removeYoungest(peerId)
        })
    };

    /**
     * @private The function called when a neighbor is unreachable and
     * supposedly crashed/departed. It probabilistically duplicates an arc.
     * @param {string} peerId The identifier of the peer that seems down.
     */
    _onPeerDown (peerId) {
        debug(&apos;[%s] ==&gt; %s ==&gt; XXX %s XXX&apos;, this.PID, this.PEER, peerId)
        // #1 remove all occurrences of the peer in the partial view
        const occ = this.partialView.removeAll(peerId)
        // #2 probabilistically recreate arcs to a known peer
        // (TODO) double check this
        const proba = this.options.a / (this.partialView.size + occ)

        if (this.partialView.size &gt; 0) {
            // #A normal behavior
            for (let i = 0; i &lt; occ; ++i) {
                if (Math.random() &gt; proba) {
                    // probabilistically duplicate the least frequent peers
                    this.connect(null, this.partialView.leastFrequent)
                }
            }
        } else {
            // #B last chance behavior (TODO) ask inview
        };
    };

    /**
     * @private A connection failed to establish properly, systematically
     * duplicates an element of the partial view.
     * @param {string|null} peerId The identifier of the peer we failed to
     * establish a connection with. Null if it was yet to be known.
     */
    _onArcDown (peerId) {
        debug(&apos;[%s] ==&gt; %s =X&gt; %s&apos;, this.PID, this.PEER, peerId || &apos;unknown&apos;)
        if (this.partialView.size &gt; 0) {
            // #1 normal behavior
            this.connect(null, this.partialView.leastFrequent)
        } else {
            // #2 last chance behavior
            // (TODO) ask inview
            // const rn = Math.floor(Math.random() * this.i.size);
            // let it = this.i.keys();
            // this.II.connect(null, this.i.
        };
    };

    /**
     * @private Inject a*log(N) + b arcs leading to peerId. When parameters are
     * not integers, the floating part is added probabilistically.
     * @param {number} a  a * log
     * @param {number} b + b
     * @param {string} peerId The identifier of the peer to duplicate.
     */
    _inject (a, b, peerId) {
        let copyA = a
        for (let i = 0; i &lt; Math.floor(a); ++i) {
            this.connect(null, peerId)
            copyA -= 1
        };
        if (Math.random() &lt; copyA) {
            this.connect(null, peerId)
        };

        let copyB = b
        for (let i = 0; i &lt; Math.floor(b); ++i) {
            this.connect(null, peerId)
            copyB -= 1
        };
        if (Math.random() &lt; copyB) {
            this.connect(null, peerId)
        };
    };
};

module.exports = Spray
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
